"use strict";(self.webpackChunkinterview_fe=self.webpackChunkinterview_fe||[]).push([[418],{5103:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-ad876594",path:"/JS/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85.html",title:"作用域与闭包",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:3,title:"谈谈你对作用域的理解",slug:"谈谈你对作用域的理解",children:[]},{level:3,title:"作用域链是什么？",slug:"作用域链是什么",children:[]},{level:3,title:"自由变量是什么？",slug:"自由变量是什么",children:[]},{level:3,title:"什么是 this，在不同情况下指向什么？🌟",slug:"什么是-this-在不同情况下指向什么",children:[]},{level:3,title:"如何改变 this 的指向？🌟",slug:"如何改变-this-的指向",children:[]},{level:3,title:"this 不同场景的取值？",slug:"this-不同场景的取值",children:[]},{level:3,title:"箭头函数使用时的注意事项？🌟",slug:"箭头函数使用时的注意事项",children:[]},{level:3,title:"什么是尾调用、尾递归？",slug:"什么是尾调用、尾递归",children:[]},{level:3,title:"谈谈你对闭包的理解？🌟",slug:"谈谈你对闭包的理解",children:[]},{level:3,title:"什么是内存泄露？",slug:"什么是内存泄露",children:[]},{level:3,title:"JavaScript 内存管理是什么？",slug:"javascript-内存管理是什么",children:[]},{level:3,title:"谈谈 JavaScript 的垃圾回收机制？",slug:"谈谈-javascript-的垃圾回收机制",children:[]}],filePathRelative:"JS/作用域与闭包.md",git:{updatedTime:1638182112e3,contributors:[{name:"brightLian",email:"brightLian@126.com",commits:4}]}}},1039:(n,s,a)=>{a.r(s),a.d(s,{default:()=>e});const p=(0,a(6252).uE)('<h1 id="作用域与闭包" tabindex="-1"><a class="header-anchor" href="#作用域与闭包" aria-hidden="true">#</a> 作用域与闭包</h1><p>这部分是 JS 三座大山中的第二座，主要题型变种多，我在本章中列举了一些经典的题目，大家在边学习知识点的同时也可以边进行练习。</p><h3 id="谈谈你对作用域的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对作用域的理解" aria-hidden="true">#</a> 谈谈你对作用域的理解</h3><ul><li>定义：作用域指的是变量和函数能被访问的区域。</li><li>作用域分为以下3类： <ul><li>全局作用域：在全局作用域中声明的变量，能够在程序中任意位置访问到。</li><li>块级作用域：在代码块内声明的变量，只能在代码块内被访问到。</li><li>函数作用域：在 JS 中每声明一个函数就会创建一个函数作用域，在函数内部声明的变量只能在函数中使用。</li></ul></li></ul><h3 id="作用域链是什么" tabindex="-1"><a class="header-anchor" href="#作用域链是什么" aria-hidden="true">#</a> 作用域链是什么？</h3><ul><li><p>定义：当在 JS 中使用一个变量的时候，首先 JS 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p></li><li><p>用途：保证变量和函数之间的有序访问。</p></li><li><p>理解：其本质是 JavaScript 在执行过程中会创造可执行上下文，可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。</p></li><li><p><strong>简言之：内部环境可以通过作用域链访问所有的外部环境中的变量和函数，外部环境不能访问内部环境中的任何变量和函数。</strong></p></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 看这个题 undefined、10、 20</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined 10 20</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10</span>\n<span class="token comment">// 原因是：函数内部 a = 20 在内部发生了变量提升，所以第一个为 undefined</span>\n<span class="token comment">// 在全局 var 声明的变量可以通过 window.xxx 访问，自执行函数声明的变量不会污染全局，所以第二个为 10</span>\n<span class="token comment">// var = 20 被赋值了，所以第三个为 20</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="自由变量是什么" tabindex="-1"><a class="header-anchor" href="#自由变量是什么" aria-hidden="true">#</a> 自由变量是什么？</h3><ul><li>定义：一个变量在当前作用域中没有定义，但是被使用了，这个变量在这里就是自由变量。</li><li>规则：在变量使用的位置向上级作用域一层一层寻找，直到找到为止。如果全局作用域都没有找到，则报错 xx is not defined。</li><li>闭包中的自由变量规则：在变量定义的位置向上级作用域一层一层寻找，而不是在函数执行的地方寻找。</li></ul><h3 id="什么是-this-在不同情况下指向什么" tabindex="-1"><a class="header-anchor" href="#什么是-this-在不同情况下指向什么" aria-hidden="true">#</a> 什么是 this，在不同情况下指向什么？🌟</h3><ul><li>定义：this 是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。</li><li>this 指向简述：this 的指向是谁调用指向谁，根据运行时的上下文确定，而不是在定义时就确定。</li><li>this 在不同情况的指向：（按照权重大小排序） <ul><li>在构造函数中被调用：this 指向构造函数所创建的实例。</li><li>使用 apply、call、bind 改变指向：根据传入的参数确定。</li><li>在对象中被调用：this 指向对象本身。</li><li>在普通函数中使用 this：this 在浏览器中指向 window，在 node.js 环境中指向 global。</li><li>在箭头函数中使用 this：this 就是它外层函数的 this，没有外层函数则指向 window/global。</li></ul></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 注意两种不同的 this</span>\n<span class="token keyword">const</span> zhangsan1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;zhangsan1&#39;</span><span class="token punctuation">,</span>\n  <span class="token function">sayThis</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 注意异步代码都是在全局作用域中执行的，因此 this 指向 window</span>\n  <span class="token function">waitSayThis</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> zhangsan2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;zhangsan2&#39;</span><span class="token punctuation">,</span>\n  <span class="token function">sayThis</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 此处因为箭头函数的 this 指向外层函数的 this</span>\n  <span class="token function">waitSayThis</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 此处因为箭头函数的 this 指向外层函数的 this，但是没有外层函数所以指向 window</span>\n  <span class="token function-variable function">waitSayThis2</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nzhangsan1<span class="token punctuation">.</span><span class="token function">sayThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前对象</span>\nzhangsan2<span class="token punctuation">.</span><span class="token function">sayThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前对象</span>\nzhangsan1<span class="token punctuation">.</span><span class="token function">waitSayThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// window，在全局调用所以指向全局</span>\nzhangsan2<span class="token punctuation">.</span><span class="token function">waitSayThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当前对象，箭头函数指向外层 this，外层的 this 为 zhangsan2 </span>\nzhangsan2<span class="token punctuation">.</span><span class="token function">waitSayThis2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// window，箭头函数指向外层 this，外层没有为 window/global</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="如何改变-this-的指向" tabindex="-1"><a class="header-anchor" href="#如何改变-this-的指向" aria-hidden="true">#</a> 如何改变 this 的指向？🌟</h3><p>apply 和 call 都是改变 this 的指向并传递参数后执行函数。</p><p>bind 是改变 this 的执行后返回一个函数，然后在调用新函数时再传递参数并执行。</p><p>注意：此外 call 的性能要比 apply 好，因为 call 接收的参数可以直接用作函数执行时的参数，省去了参数结构等操作。</p><ul><li><strong>apply：</strong> 用于在特定的作用域中调用函数，接受两个参数。一个参数是函数运行的作用域，另一个参数是函数的参数数组。</li><li><strong>call：</strong> 用于在特定的作用域中调用函数，接收不定数目参数。第一个参数是函数运行时的作用域，其余参数直接作为函数参数。</li><li><strong>bind：</strong> 创建一个新函数，接受不定数目参数，第一个参数作为函数运行时的作用域，其余参数作为函数参数，需要重新执行新的函数。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&#39;brightLian&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 相当于 window.name</span>\n<span class="token keyword">function</span> <span class="token function">fn1</span> <span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">fn1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// brightLian 0 在全局中执行</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;brightLian1&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;brightLian2&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;brightLian3&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">fn1</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// brightLian1 1 apply 改变 this 指向</span>\n<span class="token function">fn1</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// brightLian2 2 call 改变 this 指向</span>\n<span class="token keyword">let</span> fn2 <span class="token operator">=</span> <span class="token function">fn1</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bind 给新的函数绑定 this，函数不会被自动执行</span>\n<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// brightLian3 3 手动执行绑定 this 的函数</span>\n<span class="token function">fn2</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// brightLian3 4，fn2 的 this 指向不会再被改变了。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="this-不同场景的取值" tabindex="-1"><a class="header-anchor" href="#this-不同场景的取值" aria-hidden="true">#</a> this 不同场景的取值？</h3><p>注意一点即可：普通函数的 this 是在执行时确定的而非在定义时确定。</p><p>看一道简单的题目，this 在不同情况下如何取值。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  <span class="token function">getCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n<span class="token keyword">const</span> func <span class="token operator">=</span> User<span class="token punctuation">.</span>getCount<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined，函数中的 this 再执行时是 window</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1，通过 apply 改变 this 的指向</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="箭头函数使用时的注意事项" tabindex="-1"><a class="header-anchor" href="#箭头函数使用时的注意事项" aria-hidden="true">#</a> 箭头函数使用时的注意事项？🌟</h3><ul><li>函数体内的 this 对象在定义时就确定了，而不是使用时所在的对象。</li><li>不可以作为构造函数，也就是不能使用 new 命令，会报错。</li><li>不可以使用 arguments 对象，该对象在函数不存在。但是可以使用 rest 参数来代替。</li><li>不可以使用 yield 函数，因为箭头函数不能做 Generator 函数。</li></ul><h3 id="什么是尾调用、尾递归" tabindex="-1"><a class="header-anchor" href="#什么是尾调用、尾递归" aria-hidden="true">#</a> 什么是尾调用、尾递归？</h3><ul><li>尾调用：就是某个函数最后一步是调用另一个函数。</li><li>尾递归：如果尾调用的函数是自身，就是尾递归。</li></ul><h3 id="谈谈你对闭包的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对闭包的理解" aria-hidden="true">#</a> 谈谈你对闭包的理解？🌟</h3><ul><li>闭包的定义：有权访问另一个函数作用域中的变量的函数。</li><li>闭包的两种形式：函数作为参数被传递，函数作为返回值。</li><li>闭包的作用：闭包的最大作用是隐藏变量，通过它可以实现变量私有化、储存变量、保证变量不被外部侵染。</li><li>闭包中自由变量：闭包中自由变量的查找是在函数定义的位置向上级作用域查找，而不是在执行的地方查找。（和一般的自由变量不同）</li><li>闭包的缺点：闭包中的变量会常驻内存，得不到释放。有的会引起内存泄漏（在 IE 中）。</li></ul><p><strong>下面的题目重点看下：1是讲解了闭包的两种形式；2是讲解了闭包中自由变量的取值问题。</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 闭包的两种形式之一：函数作为返回值</span>\n<span class="token keyword">function</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 100 闭包中自由变量被使用时，是在其函数定义位置一层一层向上寻找。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 闭包的两种形式之一：函数作为参数</span>\n<span class="token keyword">function</span> <span class="token function">print</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>\n  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">print</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token comment">// 100 闭包中自由变量被使用时，是在其函数定义位置一层一层向上寻找。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="什么是内存泄露" tabindex="-1"><a class="header-anchor" href="#什么是内存泄露" aria-hidden="true">#</a> 什么是内存泄露？</h3><ul><li>定义：不会用到的内存，没有及时释放就是内存泄露。</li><li>引起方式： <ul><li>意外的全局变量：无法被回收。</li><li>定时器：未被正确关闭，导致所引用外部变量无法被释放。</li><li>事件监听：没有正确销毁。</li><li>闭包：父级变量无法被释放。</li></ul></li></ul><h3 id="javascript-内存管理是什么" tabindex="-1"><a class="header-anchor" href="#javascript-内存管理是什么" aria-hidden="true">#</a> JavaScript 内存管理是什么？</h3><p>JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时会 &quot;自动&quot; 释放。释放的过程称为垃圾回收。</p><ul><li>新生代内存：对象的存活时间较短，新生对象或只经过一次垃圾回收的对象。</li><li>老生代内存：对象的存活时间较长，经历过一次或多次垃圾回收的对象。</li></ul><h3 id="谈谈-javascript-的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#谈谈-javascript-的垃圾回收机制" aria-hidden="true">#</a> 谈谈 JavaScript 的垃圾回收机制？</h3><ul><li>JS 具有自动的垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存。</li><li>标记清除： <ul><li>目前主流浏览器都是采用标记清除式的垃圾回收策略。</li><li>通过给当前不使用的值加上标记，定期回收有标记的内存。</li></ul></li><li>引用计数： <ul><li>目前 JS 引擎都不再使用此方法。</li><li>通过跟踪记录所有值被引用的次数，次数为0时会被回收。</li></ul></li></ul>',38),t={},e=(0,a(3744).Z)(t,[["render",function(n,s){return p}]])},3744:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,p]of s)a[n]=p;return a}}}]);