"use strict";(self.webpackChunkinterview_fe=self.webpackChunkinterview_fe||[]).push([[863],{1199:(l,i,e)=>{e.r(i),e.d(i,{data:()=>a});const a={key:"v-054b22e6",path:"/JS/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"执行机制",slug:"执行机制",children:[{level:3,title:"var、let、const 的区别？🌟",slug:"var、let、const-的区别",children:[]},{level:3,title:"变量提升和函数提升🌟",slug:"变量提升和函数提升",children:[]},{level:3,title:"函数声明和函数表达式",slug:"函数声明和函数表达式",children:[]},{level:3,title:"什么是 JavaScript 预解析？",slug:"什么是-javascript-预解析",children:[]},{level:3,title:"一段 JavaScript 代码是如何执行的？",slug:"一段-javascript-代码是如何执行的",children:[]},{level:3,title:"JavaScript 的运行机制？",slug:"javascript-的运行机制",children:[]}]}],filePathRelative:"JS/执行机制.md",git:{updatedTime:1637575243e3,contributors:[{name:"brightLian",email:"brightLian@126.com",commits:1}]}}},5151:(l,i,e)=>{e.r(i),e.d(i,{default:()=>s});var a=e(6252);const t=(0,a.uE)('<h2 id="执行机制" tabindex="-1"><a class="header-anchor" href="#执行机制" aria-hidden="true">#</a> 执行机制</h2><h3 id="var、let、const-的区别" tabindex="-1"><a class="header-anchor" href="#var、let、const-的区别" aria-hidden="true">#</a> var、let、const 的区别？🌟</h3><ul><li>var <ul><li>作用域为该语句所在的区域内</li><li>存在变量提升现象（在变量声明语句之前可以使用这个变量，只不过为 undefined）</li><li>变量可以重复声明，以后声明的变量为准</li></ul></li><li>let <ul><li>作用域为该语句所在的代码块内</li><li>不存在变量提升</li><li>变量不可以重复声明</li></ul></li><li>const <ul><li>作用域为该语句所在的代码块内</li><li>不存在变量提升</li><li>变量不可以重复声明，且在变量声明时必须直接赋值，只声明不赋值会报错</li><li>变量一旦声明就不能修改，试图去修改 const 声明的常量就会报错（对象可以增删属性，只要地址不被改变即可）</li></ul></li></ul><h3 id="变量提升和函数提升" tabindex="-1"><a class="header-anchor" href="#变量提升和函数提升" aria-hidden="true">#</a> 变量提升和函数提升🌟</h3><ul><li>变量提升： <ul><li>定义：JS 引擎在代码执行前会先解析代码，获取所有 var 声明的变量并将定义语句一次提前到作用域的顶端，但是赋值语句还是在原本位置。然后在一行一行的执行代码</li><li>表现：表现为变量的使用可以在变量声明之前，只不过值为 undefined</li></ul></li><li>函数提升： <ul><li>定义：JS 在解析代码阶段，会将所有的函数声明依次提升到作用域的最顶端，且没有先后顺序。</li><li>表现：函数的使用语句可以在函数定义的语句后面</li></ul></li></ul><p>注意：函数提升的优先级高于变量提升</p><h3 id="函数声明和函数表达式" tabindex="-1"><a class="header-anchor" href="#函数声明和函数表达式" aria-hidden="true">#</a> 函数声明和函数表达式</h3><ul><li>写法不同： <ul><li>函数声明： function fn() {...}</li><li>函数表达式：const fn1 = function() {...}</li></ul></li><li>函数声明会在代码执行前进行函数提升，函数表达式不存在函数提升，但是通过 var 声明的函数有变量提升。</li></ul><h3 id="什么是-javascript-预解析" tabindex="-1"><a class="header-anchor" href="#什么是-javascript-预解析" aria-hidden="true">#</a> 什么是 JavaScript 预解析？</h3><p>我们大致可以把 JS 代码的运行分为两个阶段：预解析阶段和执行阶段。<br> 在预解析阶段，JS 解释器会把使用 var 声明的变量、函数提升到作用域的最顶端，同名的变量或者函数后者会覆盖前者，同时会创建执行上下文。</p><h3 id="一段-javascript-代码是如何执行的" tabindex="-1"><a class="header-anchor" href="#一段-javascript-代码是如何执行的" aria-hidden="true">#</a> 一段 JavaScript 代码是如何执行的？</h3><p>JS 代码的执行分为两个阶段：预解析阶段和执行阶段。</p><ul><li>预解析阶段：变量和函数提升、创建可执行环境的上下文。</li><li>执行阶段：按照可执行的代码顺序先后执行、通过栈管理多个执行上下文、出现报错后面代码不会再执行。</li></ul><h3 id="javascript-的运行机制" tabindex="-1"><a class="header-anchor" href="#javascript-的运行机制" aria-hidden="true">#</a> JavaScript 的运行机制？</h3>',14),r=(0,a._)("li",null,"从前到后一行一行执行",-1),n=(0,a._)("li",null,"如果某一行执行报错，则停止后面代码的执行",-1),c=(0,a.Uk)("先把同步代码执行完，再执行异步代码（"),h=(0,a.Uk)("同步异步相关可看"),u=(0,a.Uk)(")"),d={},s=(0,e(3744).Z)(d,[["render",function(l,i){const e=(0,a.up)("RouterLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[t,(0,a._)("ol",null,[r,n,(0,a._)("li",null,[c,(0,a.Wm)(e,{to:"/JS/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.html/"},{default:(0,a.w5)((()=>[h])),_:1}),u])])],64)}]])},3744:(l,i)=>{i.Z=(l,i)=>{const e=l.__vccOpts||l;for(const[l,a]of i)e[l]=a;return e}}}]);