# 浏览器相关知识点

### 前言

作为一名前端开发人员，我们有一半以上的工作是与浏览器有关的，因此很有必要对与浏览器相关原理进行一些深入的学习。

本章的知识不是很难，大多数是一些概念性的知识，主要页面的重排重绘、渲染过程、跨域等相关内容。

### 从输入一个 URL 到展示的过程？:star2:

- 浏览器先根据用户输入的 URL 读取缓存。
  - 从浏览器缓存、系统缓存、路由器缓存进行读取，如果有直接渲染页面
- 浏览器通过网址进行域名解析，查找对应的 IP 地址。
  - 先查看本地的 host 文件，是否有和这个网址的对应关系，有则直接使用这个 IP
  - 本地文件没有则向本地 DNS 服务器发送请求，一层一层查找后返回 IP 地址
  - 在这个步骤的时候会先判断是否存在 DNS 缓存
- 浏览器和服务器建立 TCP 链接。
  - TCP 连接需要进行三次握手
- 浏览器根据 IP 地址向服务器发送 HTTP 请求。
  - 在发起请求前先判断强缓存是否存在，如果未过期，直接使用资源不发起请求
- 服务器处理请求，返回相关信息给浏览器。
  - 服务器接受请求后，先判断资源是否被重定向
  - 再判断请求中的信息是否命中协商缓存
  - 命中协商缓存后返回304状态码，没有命中则返回资源信息以及新的缓存标识
- 浏览器收到资源后，对资源进行解析并渲染页面。
  - 浏览器解析各种类型的文件，然后对页面进行渲染
- 浏览器和服务器断开 TCP 连接。
  - TCP 断开连接需要进行四次挥手

### 浏览器的渲染过程

- 渲染过程的关键路径
  - 解析 HTML 生成 DOMTree
  - 解析 CSS 生成 CSSTree
  - 将 DOMTree 和 CSSTree 结合生成 renderTree
  - 根据 renderTree 开始对页面进行布局，计算每个节点对信息
  - 根据节点信息进行分层绘制
  - 不同的层复合后形成页面
- 渲染阻塞：浏览器遇到 script 标签后，DOM 构建会暂停，等待脚本完成后继续渲染。

### 什么是重绘和回流（重排）？:star2:

- 定义：
  - 重排：当元素的尺寸、大小、位置等几何属性发生变化，浏览器绘重新排列页面，此时浏览器会重新计算并进行布局，对性能损耗较大。（重排一定会触发重绘）
  - 重绘：当元素的颜色、背景等一些不会影响布局等样式发生改变，浏览器会重新绘制元素，此时只需要 UI 层面重新绘制，对性能损耗较小。
- 触发重排条件：
  - 页面初次渲染
  - 浏览器窗口大小改变
  - 元素的尺寸、大小、位置发生改变
  - 添加或删除可见的 DOM 节点
  - 激活 CSS 的伪类（如 hover、link 等）
  - 查询某些属性或者调用某些方法（如获取各种高度等）
- 避免方式：
  - 避免使用 table 布局（一个元素改变会引起整个 table 的重排）
  - 将动画效果放在 position 为 absolute 或者 fixed 元素上（使其脱离文档流）
  - 减少 DOM 的操作次数，合并一起操作。
  - 避免频繁通过 JS 来操作样式。
  - 尽量使用 CSS3的一些属性改变样式。

### window.onload 和 DOMContentLoaded 的区别:star2:

window.onload 事件在页面全部资源加载完成才会执行，包括图片、视频等资源。

DOMContentLoaded 在 DOM 渲染完成后执行，此时图片、视频还可能没加载完。

### 什么是同源策略及限制？

同源策略：用于限制一个源的文档或者加载的脚本是否可以和另一个源进行交互。

同源：同源指的是协议 + 域名 + 端口都相同的情况。

限制：当发起请求的源与被请求的源不同时，会出现跨域问题，称为限制。

### 如何解决跨域问题:star2:

注意一个大原则：所有的跨域问题都必须经过 server 端的允许和配合。

常用的跨域解决方式如下：

- JSONP
  - 利用动态创建 script 标签，不受跨域的影响，但是只能发送 GET 请求。
  - 服务器可以任意动态拼接数据返回。
- CORS
  - 利用 Access-Control-Allow-xxx 设置允许跨域的域名、方法等
  - 需要服务端设置 http-header
- Server Proxy
  - 原理是服务器之间的请求是不存在跨域问题的
  - 利用 Nginx 的方向代理功能实现
  - 客户端先请求不跨域的域名 a.com，然后 Nginx 作为服务器反向代理给 b.com

### CORS 解决跨域时如何处理 cookie？

跨域如果需要携带 cookie 时，需要前后端同时处理。

- 服务端：设置相应的 header
  - Access-Control-Allow-Credentials: true
  - Access-Control-Allow-Origin: "https://xxx.com"
  - Access-Control-Allow-Methods: *
  - Access-Control-Allow-Headers: \["Content-Type", "Authorization", "Accept"\]
  - 同时服务端的 Access-Control-Allow-Origin 不能设置为 *
- 前端需要在请求时设置：
  - xhr.withCredentials = true

### JSONP 的原理？为什么它不是一个 ajax？

原理：静态资源请求不受同源策略限制。通过动态创建 script 标签，基于回调函数。但是只能发送 GET 请求。

为什么不是 ajax：

- ajax 的核心是通过 XMLHttpRequest 获取非本页内容。
- JSONP 的核心则是动态添加 script 标签来调用服务器提供的 js 脚本。

实现：[JSONP的实现](../JS/JS手写代码.html#实现-jsonp)

### 前端实时通讯的实现？

你可能会好奇为什么把前端实时通信的模块放在这部分来说明？因为目前越来越多的 IM 是基于 Websocket、SSE 等来实现。你可以给它归结为 HTML5，也可以给它归结为 HTTP相关。
我们重点是看它的实现方式，就先不纠结它属于哪类题目了。

- **短轮询：**
  - 定义：借助定时器客户端每隔一段时间向服务器发送请求，服务器接收到情况后立即返回数据。
  - 优点：兼容性强，实现起来很简单。
  - 缺点：实时性比较低。请求中有大半是无用，非常消耗服务器资源，造成性能上的浪费。

- **长轮询：**
  - 定义：客户端向服务器发送请求，服务器接到请求 hold 住连接，直到有服务端数据被更新，它就使用这个连接发送数据给客户端。
  - 优点：对比短轮询左右优化，时效性比较强。
  - 缺点：占用较多资源和连接数。

- **SSE：**
  - 定义：服务器通过向客户端声明发送流信息，建立一个长时间的连接，利用流信息向客户端推送消息。
  - 优点：轻量级、简单、基于 HTTP 协议支持性强。
  - 缺点：因为流消息的本质是下载，所以是单向通道，只能服务器向客户端发送消息。

- **webSocket：**
  - 定义：H5 定义的一种 API，基于 TCP 传输协议，复用 HTTP 的通道建立连接。使 web 页面能够使用 WebSocket 协议与服务器进行双向通信。
  - 优点：开销小，双向通信，支持二进制传输。
  - 缺点：开放成本高，需要进行重连保活、心跳检测等。
  
