# 前端性能优化

### 你的性能优化原则是怎样的？

- 多使用内存、缓存或者其他方法
- 减少 CPU 计算量，减少网络加载耗时
- 现阶段设备的存储能力都是比较先进的，所以性能优化的通用规则就是空间换时间

### 性能优化从何入手？:star2:

- 我认为性能优化无非就是从两方面入手：让资源加载的更快、让页面渲染的更快。
- 让资源加载的更快，提升网络资源加载的速度
  - 利用浏览器的缓存：使用强缓存和协商缓存，不去重复的加载相同的资源。
  - 减少 HTTP 请求：图片使用雪碧图，接口返回的重复静态数据存储本地（省市地区联动）。
  - 使用 HTTP2：多路复用（多个请求共用一个 TCP 连接）、首部压缩（重复数据只发送一次）
  - nginx 开启 gzip 模式：对资源进行压缩。
  - 使用服务端渲染：数据预先填充到页面，客户端直接渲染页面。
  - 静态资源使用 CDN：减少资源请求的延迟。
  - 压缩资源体积：我个人是使用 webpack 及一些插件进行压缩。
    - uglifyjs-webpack-plugin：压缩代码
    - mini-css-extract-plugin： 提取 CSS 到单独到文件
    - 使用 webpack 抽离公共代码（splitChunks）
    - 使用 compression-webpack-plugin 开启 gzip 压缩
- 让页面渲染的更快，优化页面渲染的过程
  - CSS 放在文件头部，JS 放在文件底部：CSS 不会阻塞 DOM 解析，可以让用户先看到页面的样式。
  - 图片懒加载：图片不再可视区域先给不给图片设置路径，图片到达可视区域时才去加载真正的图片。
  - 避免页面过多的重排和重绘
  - 尽早执行 JS，用 DOMContentLoaded 触发
  - 使用 requestAnimationFrame：JS 实现动画时使用，避免卡顿和丢帧。
  - 对 DOM 查询进行缓存：DOM 操作比较昂贵，对常用的 DOM 进行缓存。
  - 频繁 DOM 操作合并到一起插入 DOM 结构：一次插入多个 DOM 节点可以使用 createDocumentFragment。
  - prefetch 和 preload：可以利用 webpack 的内置指令，告知浏览器在闲置时加载指定资源。
  - 函数的节流和防抖

### 你做过哪些性能优化来提升用户体验？:star2:

### 首屏加载优化方式有哪些？:star2:

- 骨架屏：页面内容未加载完时，先使用图形占位，内容加载完后将其替换掉。
- 路由懒加载：当路由被访问时，再去加载对应组件。
- 图片懒加载：图片不再可视区域先给不给图片设置路径，图片到达可视区域时才去加载真正的图片。
- 接口返回的重复静态数据存储本地：比如地区列表可以用 localStorage 存储到本地。
- 静态资源使用 CDN 加速：减少资源请求的延迟。
- 使用服务端渲染：数据预先填充到页面，客户端直接渲染页面。
- 使用 UI 库的时候按需加载：UI 库的大小都比较大，对需要的内容按需加载。
- webpack 开启 gzip 压缩。
- nginx 开启 gzip 模式。

### node 的负载均衡

- 定义：多台服务器同时工作，不让其中的某一台或者几台超额工作，发挥服务器的最大作用。
- 方式：
  - http 重定向负载均衡：调度者根据策略选择服务器以302响应请求，但是只有一次效果，之后操作都会在此服务器。
  - dns 负载均衡：解析域名时，访问多个 IP 服务器中的一个。
  - 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大。

### 图片懒加载实现

- 定义：在当前网页，滑动页面到能看到图片的时候再加载图片。
- 核心问题：
  - 如何判断图片出现在了当前视口
  - 如何控制图片的加载
- 解决方案1：
  - clientTop，offsetTop，clientHeight 以及 scrollTop 各种关于图片的高度作比对
  - 首先设置一个临时属性 data-src，控制加载时使用 src 代替 data-src
