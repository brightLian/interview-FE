## 原型与原型链

JS 有三大必考知识点：原型与原型链、作用域与闭包、同步与异步。

本章节是三大必考点之一，大多数公司在面试的时候都会涉及到这部分的题目。

### 描述下原型和原型链:star2:

- 原型
  - 每一个构造函数都有一个显示原型 prototype
  - 每一个实例都有一个隐式原型 \_\_proto\_\_
  - 实例的隐式原型等于构造函数的显示原型
- 原型链
  - 访问一个实例中的方法或者属性，找不到会自动去 \_\_proto\_\_ 中寻找，知道最后查找到 Object.prototype 中，如果还找不到就返回 null
  - 我们可以通过 hasOwnPrototype 来确定属性或者方法是否是实例自身的

```javascript
let o1 = new Object({
  name: 'brightLian',
  sayName: function () {
    console.log(this.name)
  }
});
Object.prototype; // 构造函数的显示原型
o1.__proto__; // 实例的隐式原型
Object.prototype === o1.__proto__; // true 实例的隐式原型===构造函数的显示原型
o1.sayName(); // 调用实例的方法
o1.toString(); // 调用构造函数的方法
o1.xxx; // 获取不存在的属性 undefined
o1.xxx(); // 获取不存在的方法，报错
o1.hasOwnProperty('sayName'); // true 判断 sayName 是否是实例的自有属性
o1.hasOwnProperty('toString'); // false 判断构造函数的方法是不是实例的自有属性
```

### 原型、构造函数、实例之间的关系:star2:

- 关系：我们假设 o1 是通过 Object 实例化出来的
  - 实例是通过构造函数 new 出来的
  - 实例的隐式原型等于构造函数的显示原型：o1.\_\_proto\_\_ === Object.prototype
  - 实例的 constructor 等于构造函数：o1.constructor === Object
- 不能给构造函数直接添加属性，但可以通过给构造函数的原型添加属性
- 每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针
- 可以通过 instanceof 操作符来确定原型和实例之间的关系

```javascript
let o1 = new Object();
// 错误写法，不能直接给构造函数添加属性
// Object.log1 = function() {
//   console.log(1);
// }
// o1.log1(); // 报错
// 正确写法，给构造函数的显示原型添加属性
Object.prototype.log1 = function () {
  console.log(1);
};
o1.log1(); // 1，不会报错
o1.__proto__ === Object.prototype; // true 实例的隐式原型 === 构造函数的显示原型 两个原型对象的指针相同
o1.constructor === Object; // true 实例的 constructor === 构造函数
o1 instanceof Function; // false
o1 instanceof Object;  // true 可以通过 instanceof 来确定原型和实例之间的关系
```

### new 运算符的执行过程:star2:

1.在内存中新创建一个空对象 2.链接到原型，即让空对象的隐式原型等于其构造函数的显示原型 3.将新创建的对象作为 this 的上下文（构造函数内部的 this 被赋值为这个新对象） 4.返回新的对象

```javascript
function myNew () {
  const params = [...arguments];
  const thisConstructor = params[0]; // 获取构造函数
  const args = params.slice(1); // 获取其余参数
  // 1.在内存中声明一个对象
  const o = {};
  // 2.对象的隐式原型链接到构造函数的显示原型
  o.__proto__ = thisConstructor.prototype;
  // 3.绑定 this
  const result = thisConstructor.apply(o, args);
  // 4.返回值，考虑 new Object 的情况
  return result instanceof Object ? result : o;
}

function Person (name, number) {
  this.name = name;
  this.number = number;
}

const per1 = myNew(Person, 'brightLian', '1');
const per2 = new Person('xxs', '2');
const per3 = myNew(Object, {
  name: 'ljc',
  age: '3'
});
console.log(per1);
console.log(per2);
console.log(per3);
```

### {}、new Object() 和 Object.create() 的区别？

- 主要体现在原型：
  - {} 等同于 new Object()，原型是 Object.prototype
  - Object.create() 方法创建一个新对象，使用现有的对象来提供新创建对象的 \_\_proto\_\_。Object.create(null) 没有原型，Object.create({...}) 可以指定原型

```javascript
const obj1 = {
  a: 1,
  b: 2,
  sum () {
    return this.a + this.b
  }
};

const obj2 = new Object({
  a: 1,
  b: 2,
  sum () {
    return this.a + this.b
  }
});

const obj3 = Object.create(null); // 无属性无原型

const obj4 = new Object(); // 无属性有原型

const obj5 = Object.create({
  a: 1,
  b: 2,
  sum () {
    return this.a + this.b
  }
}); // 无属性有原型，但是属性会绑定到原型上

const obj6 = Object.create(obj1); // 无属性有原型，obj6原型被绑定到obj1
console.log(obj6.b) // 2，obj1 为 obj6 的原型，自身找不到回去原型链上找
obj6.a = 1.1;
console.log(obj1.a) // 1
console.log(obj6.a) // 1.1 继承来的属性可以被重写 
console.log(obj1 === obj6.__proto__); // true
```

### instanceof 原理？

检测构造函数的 prototype 属性是否出现在实例的原型链上。(右操作数的 prototype 是否出现在左操作数的原型链上)

```javascript
// 递归方式
function myInstanceof (leftValue, rightValue) {
  // 左操作数的隐式原型
  const leftValueProto = leftValue.__proto__;
  // 右操作数的显示原型
  const rightValuePrototype = rightValue.prototype;
  // 循环调用出现左操作数的隐式原型为 null 时
  if (leftValueProto === null) {
    return false
  }
  // 左操作数的隐式原型等于有操作数的显示原型
  if (leftValueProto === rightValuePrototype) {
    return true
  }
  // 循环调用
  return myInstanceof(leftValueProto, rightValue);
}

// 循环方式
function myInstanceof2 (leftValue, rightValue) {
  let leftValueProto = leftValue.__proto__;
  while (leftValueProto) {
    if (leftValueProto === rightValue.prototype) {
      return true
    }
    leftValueProto = leftValueProto.__proto__
  }
  return false
}
```

### 继承的方式？

- ES5：最常使用原型链 + 构造函数结合实现继承。（使用原型链实现对属性和方法的继承，使用构造函数来实现对实例属性的继承。）
- ES6：使用 class 通过 extends 进行继承。

### ES5 和 ES6继承方式比较？

- 在ES5中，继承实质上是子类先创建属于自己的 this，然后再将父类的方法添加到 this（也就是使用 Parent.apply(this)的方式
- 在ES6中，则是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。

```javascript
// 组合式继承
function SuperType (name) {
  this.name = name
}

SuperType.prototype.sayName = function () {
  console.log(this.name);
}

function SubType (name, age) {
  // 继承属性
  SuperType.call(this, name);
  this.age = age
}

// 继承方法
SubType.prototype = new SuperType();
SuperType.prototype.sayAge = function () {
  console.log(this.age);
}
```

### 谈谈对 class 的理解？:star2:

- 实际 class 是一个语法糖，其底层还是通过原型链去创建的。所以它的绝大部分功能，ES5都可以做到。新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
- **constructor：** 用于在类的定义块内部创建类的构造函数，告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。
- **属性：** 构造函数内部代码执行后，通过 this 绑定给实例绑定的值。
- **方法：** 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。
- **继承 extends：**
  - **super：** super 作为函数调用时，代表父类的构造函数。同时ES6要求，子类的构造函数必须执行一次 super 函数。
  - **扩展和重写：** 子类中的方法可以覆盖父类中的方法。
- **原型关系：**
  - 每个 class 都有显示原型 prototype
  - 每个实例都有隐式原型 \_\_proto\_\_
  - class 的显示原型与实例的隐式原型相等
- **基于原型的执行规则：**
  - 获取某个属性或方法时先在自身属性和方法中寻找
  - 如果找不到自动去 \_\_proto\_\_ 中去寻找

```javascript
// 声明一个基类
class People {
  constructor (name) {
    this.name = name
  }

  eat () {
    console.log(`${this.name} eating something`)
  }
}

// 子类1 Student 继承于基类 People
class Student extends People {
  constructor (name, number) {
    super(name);
    this.number = number;
    this.sayNumber = function () {
      console.log(`${this.name} number is ${this.number}`)
    }
  }

  sayHi () {
    console.log(`姓名：${this.name}，学号：${this.number}`)
  }
}

// 子类2 Teacher 继承于基类 People
class Teacher extends People {
  constructor (name, major) {
    super(name);
    this.major = major;
    this.eat = function () {
      console.log(`${this.name} eating everything`)
    }
  }

  teachSome () {
    console.log(`姓名：${this.name}，科目：${this.major}`)
  }
}

// 声明一个 Student 的实例
let xiaoluo = new Student('xiaoluo', 1);
// 声明一个 Teacher 的实例
let teacherWang = new Teacher('teacherWang', '语文');
xiaoluo.eat(); // 实例的 class 中没有这个方法，去其 class 父类中寻找
teacherWang.eat(); // 对父类方法重写后再调用
console.log(Student.prototype);
console.log(xiaoluo.__proto__);
console.log(Student.prototype === xiaoluo.__proto__); // class 的显示原型等于其实例的隐式原型
console.log(Student.prototype.__proto__);
console.log(People.prototype === Student.prototype.__proto__); // true 子 class 的显示原型的隐式原型等于其父 class 的显示原型
console.log(teacherWang.constructor === Teacher); // true 实例的 constructor 等于其构造函数
console.log(xiaoluo.hasOwnProperty('sayHi')); // false class 中的方法
console.log(xiaoluo.hasOwnProperty('sayNumber')); // true 构造函数自身的方法
console.log(xiaoluo.hasOwnProperty('name')); // true 构造函数自身的属性
console.log(xiaoluo.hasOwnProperty('eat')); // false class 的父类中的方法
console.log(teacherWang.hasOwnProperty('eat')); // true 自身属性重写了父类的属性
```

图片解析如下:
![原型链图片解析](/image/JS/原型与原型链.png)

### class 原型本质是什么？

本质是 function，我们可以通过 typeof 来查看。

```javascript
class Person {
  constructor (name) {
    this.name = name
  }
}

typeof Person; // function
Person instanceof Function // true
```

### es6 class 的 constructor 里面和外面的方法有什么区别？

```javascript
/* A类，方法写在constructor里面 */
class A {
  constructor () {
    this.show = function () {
      console.log('A show')
    }
  }
}

const a = new A()
a.show() // => A show

/* B类，方法写在constructor外面 */
class B {
  constructor () {
  }

  show () {
    console.log('B show')
  }
}

const b = new B()
b.show()  // => B show
```

问题也就是：A 类的 show 方法和 B 类的 show 方法调用结果都一样，那么请问写在 constructor 里和外面的区别是？

```javascript
const a1 = new A();
const a2 = new A();
console.log(a1.show === a2.show);// false

const b1 = new B();
const b2 = new B();
console.log(b1.show === b2.show);// true
```

我们通过上面的代码可以看出：两种方法的调用结果虽然相同，但是一个是原型方法，一个是实例方法。     
实例方法（即写在 constructor 内的）在使用 new 关键字实例化的时候，new 的内部实现中，会改变 this 指向，所以每个实例的 show 方法都不一样，只是同名而已。

换成 es5 就更加清晰了：

```javascript
// 写在里面
function A () {
  this.show = function () {
  }
}
// 写在外边
function B () {}
B.prototype.show = function(){}
```
